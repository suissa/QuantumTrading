![](https://i.imgur.com/iXYr3VT.png)


# QuantumTrading

Nesse reposit√≥rio eu vou repassar os algoritmos qu√¢nticos que utilizo para Trading.

## QAOA (Quantum Approximate Optimization Algorithm)

O QAOA (Quantum Approximate Optimization Algorithm) √© um algoritmo h√≠brido qu√¢ntico-cl√°ssico desenvolvido para resolver problemas de otimiza√ß√£o combinat√≥ria, como problemas de portf√≥lio financeiro, roteamento, sele√ß√£o de trading e outros. Ele funciona aplicando camadas alternadas de opera√ß√µes qu√¢nticas para aproximar a melhor solu√ß√£o poss√≠vel.

## Fundamentos do QAOA
O QAOA √© projetado para resolver problemas de QUBO (Quadratic Unconstrained Binary Optimization) e problemas modelados como um Hamiltoniano de Ising, que podem ser descritos por:
Estrutura do Algoritmo
O QAOA combina computa√ß√£o qu√¢ntica e otimiza√ß√£o cl√°ssica. Ele segue estes passos:

1. Definir o problema como um Hamiltoniano (Hamiltoniano de Custo).
2. Escolher uma Hamiltoniana de Mixer para explorar o espa√ßo de solu√ß√µes.
3. Construir um circuito qu√¢ntico parametrizado com camadas alternadas de gates baseadas nesses Hamiltonianos.
4. Executar o circuito e medir os resultados, ajustando os par√¢metros com um otimizador cl√°ssico.

## Componentes Chave do Algoritmo

O QAOA tem tr√™s partes principais:

- Hamiltoniano de Custo: Representa o problema de otimiza√ß√£o.
- Hamiltoniano de Mixer: Explora poss√≠veis solu√ß√µes.
- Par√¢metros Variacionais: Ajustam a evolu√ß√£o do circuito.

## Defini√ß√£o dos Hamiltonianos

Os dois Hamiltonianos s√£o aplicados iterativamente no circuito qu√¢ntico.

- Hamiltoniano de Custo: Este Hamiltoniano codifica a fun√ß√£o objetivo do problema. Se estivermos resolvendo um problema QUBO, √© definido como:
onde:

![Hamiltonianos de custo](https://quicklatex.com/cache3/92/ql_77c199a9317eef6d78cab55f77cd6a92_l3.png)


ùëÑùëñùëó: s√£o os coeficientes da matriz QUBO.
ùëçùëñ: √© o operador de Pauli-Z aplicado ao qubit 
- O estado de menor energia do sistema qu√¢ntico representar√° a melhor solu√ß√£o.

### O que o Operador Pauli-X faz?

O operador Pauli-X (ùëã) age como um interruptor, trocando os estados dos qubits:

- Se um qubit estiver no estado ‚à£0‚ü©, o Pauli-X o transforma em ‚à£1‚ü©.
- Se um qubit estiver no estado ‚à£1‚ü©, o Pauli-X o transforma em ‚à£0‚ü©.

Isso significa que o Hamiltoniano de Mixer age mudando os valores das vari√°veis no sistema, permitindo a explora√ß√£o de novas solu√ß√µes.

- Hamiltoniano de Mixer: O Mixer permite a explora√ß√£o do espa√ßo de solu√ß√µes. 

Ele √© definido como:

![Hamiltoniano Mixer](https://quicklatex.com/cache3/47/ql_075ae5b341295dfd833e1ad53a19c447_l3.png)

ùëãùëñ: √© o operador de Pauli-X aplicado ao qubit 
- Este Hamiltoniano gira os qubits, permitindo explorar diferentes configura√ß√µes.

A f√≥rmula calcula a energia total de uma configura√ß√£o de vari√°veis, levando em conta tanto intera√ß√µes entre vari√°veis quanto o efeito de cada vari√°vel isoladamente, ajudando o QAOA a encontrar a melhor solu√ß√£o poss√≠vel para um problema de otimiza√ß√£o.

## Constru√ß√£o do Circuito Qu√¢ntico

O circuito QAOA √© montado aplicando camadas alternadas de ùêªC e ùêªM, ajustadas pelos par√¢metros variacionais (ùõæ,ùõΩ).

1. Inicializa√ß√£o
- Preparamos um estado inicial uniforme superposto

2. Aplica√ß√£o do Hamiltoniano de Custo
- Aplicamos gates de fase controladas, codificando a fun√ß√£o objetivo no sistema qu√¢ntico.

3. Aplica√ß√£o do Hamiltoniano de Mixer
- Aplicamos rota√ß√µes, permitindo que o sistema explore diferentes solu√ß√µes.

4. Medi√ß√£o
- O circuito √© medido em base computacional ‚à£0‚ü©,‚à£1‚ü© para encontrar a solu√ß√£o √≥tima.

5. Otimiza√ß√£o Cl√°ssica
- Ajustamos os par√¢metros Œ≥,Œ≤ usando um otimizador cl√°ssico (ex.: COBYLA, SPSA, Nelder-Mead).
- Repetimos o processo at√© encontrar o melhor valor.

### O que √© o Operador Pauli-Z?
O Pauli-Z (ùëç) √© um dos tr√™s operadores de Pauli, fundamentais na mec√¢nica qu√¢ntica e na computa√ß√£o qu√¢ntica. Ele √© representado pela matriz de Pauli-Z:
[ 1 0
  0‚àí1]
  
Esse operador age sobre qubits, alterando seu estado de uma maneira espec√≠fica.

- Como o Pauli-Z funciona na computa√ß√£o qu√¢ntica?
O operador Z n√£o altera o estado ‚à£0‚ü©, mas inverte o sinal do estado ‚à£1‚ü©:

Se aplicado ao qubit no estado ‚à£0‚ü©, o qubit permanece igual: Z‚à£0‚ü© = ‚à£0‚ü©
Se aplicado ao qubit no estado ‚à£1‚ü©, o qubit muda de sinal: Z‚à£1‚ü© = ‚àí‚à£1‚ü©
Isso significa que o operador introduz uma fase negativa no qubit ‚à£1‚ü©, mas n√£o afeta ‚à£0‚ü©.

- Interpreta√ß√£o F√≠sica do Pauli-Z
O operador Pauli-Z est√° diretamente relacionado ao eixo Z da esfera de Bloch, que representa os estados qu√¢nticos geometricamente.

- ‚à£0‚ü© est√° no topo da esfera de Bloch e n√£o √© afetado pelo Pauli-Z.
- ‚à£1‚ü© est√° na parte inferior da esfera de Bloch e recebe um fator de fase -1 quando o Pauli-Z √© aplicado.

Isso significa que o operador Pauli-Z reflete os qubits em torno do eixo Z.

#### Uso do Pauli-Z na Computa√ß√£o Qu√¢ntica

O operador Pauli-Z aparece em v√°rios contextos, incluindo:

- Corre√ß√£o de Erros Qu√¢nticos: o Pauli-Z pode ser usado para detectar e corrigir certos tipos de erros em qubits.


#### Medi√ß√µes em Circuitos Qu√¢nticos

Muitas medi√ß√µes na computa√ß√£o qu√¢ntica s√£o feitas na base Z, onde o Pauli-Z ajuda a distinguir entre ‚à£0‚ü© e ‚à£1‚ü©.


#### QAOA e Modelos de Ising

No Quantum Approximate Optimization Algorithm (QAOA), o operador Pauli-Z √© usado para definir restri√ß√µes e intera√ß√µes entre qubits, modelando problemas como otimiza√ß√£o financeira e problemas log√≠sticos.
4Ô∏è‚É£ Portas de Fase (RZ Gate)

O operador Pauli-Z pode ser visto como um caso especial da porta RZ(Œ∏), usada para adicionar fases em circuitos qu√¢nticos.

No QAOA, ele aparece na Hamiltoniana de Custo para definir rela√ß√µes entre vari√°veis, ajudando a resolver problemas como trading e portf√≥lio financeiro.




## Exemplo de Implementa√ß√£o no Qiskit

```py
from qiskit import Aer
from qiskit.optimization import QuadraticProgram
from qiskit_optimization.translators import from_docplex_mp
from qiskit.algorithms import QAOA
from qiskit.primitives import Estimator
from qiskit.algorithms.optimizers import COBYLA
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from docplex.mp.model import Model

# Criar o problema de otimiza√ß√£o (QUBO)
mdl = Model('QAOA_Optimization')
x1 = mdl.binary_var(name='x1')
x2 = mdl.binary_var(name='x2')
x3 = mdl.binary_var(name='x3')

# Definir a fun√ß√£o objetivo (minimizar -x1x2 - x2x3 + x1)
mdl.maximize(-x1 * x2 - x2 * x3 + x1)

# Converter para QUBO
qp = from_docplex_mp(mdl)

# Criar simulador e otimizador QAOA
estimator = Estimator()
qaoa = QAOA(estimator, optimizer=COBYLA())

# Resolver o problema
optimizer = MinimumEigenOptimizer(qaoa)
result = optimizer.solve(qp)

# Exibir solu√ß√£o
print("Melhor Solu√ß√£o:", result.x)
print("Valor √ìtimo:", result.fval)

```


## Explica√ß√£o do C√≥digo
- Criamos um problema QUBO com vari√°veis 

- Definimos a fun√ß√£o objetivo.

- Convertamos para um Hamiltoniano qu√¢ntico.

- Aplicamos QAOA para encontrar a solu√ß√£o.

- Medimos os qubits e ajustamos os par√¢metros com um otimizador cl√°ssico.


## Aplica√ß√µes do QAOA

O QAOA pode ser usado para otimizar:

- Trading Algor√≠tmico ‚Üí Ajuste de par√¢metros de indicadores como RSI, MACD, Bandas de Bollinger.

- Sele√ß√£o de Portf√≥lio ‚Üí Escolher ativos maximizando retorno e minimizando risco.

- Roteamento Log√≠stico ‚Üí Encontrar o caminho mais eficiente para entregas.

- Aloca√ß√£o de Recursos ‚Üí Escolher a melhor distribui√ß√£o de investimentos.


| Algoritmo	| Caracter√≠sticas |
------------|-----------------|
| QAOA	| Aproxima solu√ß√µes combinat√≥rias usando circuitos qu√¢nticos |
| Branch & Bound	| Divide o problema em subproblemas e explora solu√ß√µes |
| Algoritmos Gen√©ticos	| Evolui solu√ß√µes atrav√©s de muta√ß√£o e sele√ß√£o |
| Programa√ß√£o Linear	| Resolve problemas com restri√ß√µes lineares |




Como o QAOA sabe que encontrou uma solu√ß√£o otimizada?
O QAOA (Quantum Approximate Optimization Algorithm) otimiza um problema baseado na minimiza√ß√£o de energia da Hamiltoniana de Custo (ùêªùê∂). Mas como ele sabe que est√° otimizado? Ele segue tr√™s crit√©rios principais:


1. Mede os qubits e verifica qual estado aparece com mais frequ√™ncia

No final da execu√ß√£o do circuito qu√¢ntico, os qubits s√£o medidos. 
O QAOA repete o experimento v√°rias vezes e registra quais estados aparecem com mais frequ√™ncia.

- Se um determinado estado aparece muitas vezes, isso indica que ele tem a menor energia poss√≠vel ‚Üí significa que ele √© provavelmente a melhor solu√ß√£o.


2. Mede a energia da solu√ß√£o

O QAOA calcula a energia associada ao estado mais frequente.

A energia √© dada por:

![](https://quicklatex.com/cache3/2c/ql_d51cd2b3088c1d8af440aaf90200652c_l3.png)

3. O Algoritmo Variacional Ajusta os Par√¢metros
4. 
O QAOA usa otimiza√ß√£o cl√°ssica para encontrar os melhores valores de ùõæ e ùõΩ, que controlam a evolu√ß√£o do circuito.

- O circuito come√ßa com um chute inicial de ùõæ e ùõΩ.
- Executa e mede os qubits.
- Calcula a energia do estado encontrado.
- Ajusta ùõæ e ùõΩ para reduzir ainda mais a energia.
- Repete at√© encontrar a melhor solu√ß√£o.

- Ele otimiza como um jogador de xadrez que aprende com seus erros: se o movimento anterior n√£o foi bom, ele tenta outro at√© encontrar a estrat√©gia vencedora.

Como saber se a solu√ß√£o encontrada √© boa?

- O estado mais frequente entre as medi√ß√µes indica a melhor solu√ß√£o.
- Se a energia do sistema for m√≠nima, ent√£o essa √© provavelmente a melhor configura√ß√£o poss√≠vel.
- O otimizador cl√°ssico ajusta os par√¢metros at√© que a energia n√£o diminua mais.
- Comparamos com solu√ß√µes cl√°ssicas para ver se a resposta do QAOA bate com solu√ß√µes exatas.



 
---

Bom com isso voc√™ j√° aprendeu bastanet sobre Otimiza√ß√£o Qu√¢ntica, agora √© a hora de escolher os indicadores a serem otimizados, no mundo da an√°lise t√©cnica n√≥s temos 6 categorias de indicadores:

1. Indicadores de Tend√™ncia

Objetivo: Identificar a dire√ß√£o predominante do mercado (tend√™ncia de alta, baixa ou lateral). 
Como Funcionam: Calculam m√©dias ou suavizam pre√ßos para detectar tend√™ncias e revers√µes.

Exemplos:
- M√©dias M√≥veis (SMA, EMA, WMA, ALMA) ‚Äì Suavizam pre√ßos para mostrar a tend√™ncia.
- MACD (Moving Average Convergence Divergence) ‚Äì Mede a for√ßa e a dire√ß√£o da tend√™ncia com m√©dias m√≥veis.
- ADX (Average Directional Index) ‚Äì Mede a for√ßa da tend√™ncia, mas n√£o sua dire√ß√£o.
- Ichimoku Kinko Hyo ‚Äì Fornece suporte, resist√™ncia e dire√ß√£o de tend√™ncia em um √∫nico gr√°fico.


2. Indicadores de Momentum (For√ßa)

Objetivo: Medir a velocidade das mudan√ßas nos pre√ßos e identificar momentos de entrada e sa√≠da. 
Como Funcionam: Comparam pre√ßos atuais e passados para medir a for√ßa da tend√™ncia.

Exemplos:
- RSI (Relative Strength Index) ‚Äì Mede a for√ßa do movimento de pre√ßos e detecta sobrecompra/sobrevenda.
- Estoc√°stico ‚Äì Compara o pre√ßo de fechamento com a faixa de pre√ßos passada para indicar revers√µes.
- CCI (Commodity Channel Index) ‚Äì Mede varia√ß√µes de pre√ßo em rela√ß√£o a uma m√©dia estat√≠stica.
- Momentum ‚Äì Mede a taxa de mudan√ßa do pre√ßo ao longo do tempo.


3. Indicadores de Volume

Objetivo: Analisar o volume de negocia√ß√µes para confirmar tend√™ncias e prever revers√µes. 
Como Funcionam: Observam se o volume aumenta ou diminui em rela√ß√£o aos pre√ßos.

Exemplos:
- OBV (On-Balance Volume) ‚Äì Mede o fluxo de volume baseado em alta e baixa de pre√ßos.
- Volume Profile ‚Äì Analisa onde o volume foi negociado em diferentes n√≠veis de pre√ßo.
- MFI (Money Flow Index) ‚Äì Indica press√£o de compra/venda combinando pre√ßo e volume.
- VWAP (Volume Weighted Average Price) ‚Äì Calcula a m√©dia do pre√ßo ponderada pelo volume.


4. Indicadores de Volatilidade

Objetivo: Medir a varia√ß√£o e a imprevisibilidade dos pre√ßos para antecipar mudan√ßas no mercado. 
Como Funcionam: Analisam a amplitude dos pre√ßos e sua varia√ß√£o ao longo do tempo.

Exemplos:
- Bandas de Bollinger ‚Äì Criam uma faixa ao redor do pre√ßo para indicar se est√° sobrecomprado ou sobrevendido.
- ATR (Average True Range) ‚Äì Mede a volatilidade do mercado ao calcular a m√©dia da amplitude dos pre√ßos.
- Keltner Channels ‚Äì Funciona como as Bandas de Bollinger, mas usa m√©dias m√≥veis.
- VIX (√çndice de Volatilidade) ‚Äì Mede a volatilidade impl√≠cita no mercado de a√ß√µes.


5. Indicadores de Suporte e Resist√™ncia

Objetivo: Identificar n√≠veis onde os pre√ßos tendem a reverter ou consolidar. 
Como Funcionam: Calculam pontos estrat√©gicos com base em m√°ximas, m√≠nimas e m√©dias anteriores.

Exemplos:
- Piv√¥s ‚Äì Calculam pontos de suporte e resist√™ncia com base nos pre√ßos anteriores.
- Fibonacci Retracement ‚Äì Usa propor√ß√µes matem√°ticas para identificar zonas de suporte e resist√™ncia.
- Linhas de Tend√™ncia ‚Äì Identificam n√≠veis psicol√≥gicos importantes baseados em m√°ximas e m√≠nimas anteriores.


6. Indicadores de Ciclos e Estat√≠sticos

Objetivo: Identificar padr√µes e ciclos de mercado que podem influenciar os pre√ßos. 
Como Funcionam: Utilizam c√°lculos matem√°ticos para prever mudan√ßas de comportamento do mercado.

Exemplos:
- Elliott Wave Theory ‚Äì An√°lise de padr√µes de ondas para prever ciclos de alta e baixa.
- Fourier Transform ‚Äì Identifica ciclos ocultos nos pre√ßos do mercado.
- Detrended Price Oscillator (DPO) ‚Äì Remove tend√™ncias para focar nos ciclos de curto prazo.


Ent√£o a ideia ou escolher uma ou duas categorias e focar em um timeframe pequeno, m√©dio ou grande, ou fazer um completo abrangendo todas as categorias.

Mas al√©m dos indicadores n√≥s tamb√©m podemos otimizar o valor do StopLoss e do TakeProfit, isso muda completamente a sua estrat√©gia, vai por mim.

Escolhi 4 indicadores b√°sicos como um exemplo: 

- MACD
- RSI
- OBV
- ATR

E esse √© nosso c√≥digo de Otimiza√ß√£o Qu√¢ntica. Eu indico a voc√™ rodar esse c√≥digo IBM Quantum.


```py
import numpy as np
import requests
import pandas as pd
import ta
import matplotlib.pyplot as plt
from datetime import datetime
from qiskit import Aer
from qiskit.algorithms import QAOA
from qiskit.primitives import Estimator
from qiskit.algorithms.optimizers import COBYLA
from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from docplex.mp.model import Model
import random

# - Lista para armazenar logs das ordens abertas/fechadas
trade_log = []

# - Fun√ß√£o para buscar dados do BTC/USDT em 5m da Binance
def get_binance_data(symbol="BTCUSDT", interval="5m", limit=500):
    url = f"https://api.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={limit}"
    response = requests.get(url).json()
    df = pd.DataFrame(response, columns=['time', 'open', 'high', 'low', 'close', 'volume', 
                                         'close_time', 'qav', 'trades', 'taker_base', 'taker_quote', 'ignore'])
    df = df[['time', 'open', 'high', 'low', 'close', 'volume']].astype(float)
    df['time'] = pd.to_datetime(df['time'], unit='ms')
    return df

# - Calcula indicadores t√©cnicos
def calculate_indicators(df, macd_short=12, macd_long=26, macd_signal=9, rsi_length=14, atr_length=14):
    df['MACD'] = ta.trend.macd(df['close'], window_slow=macd_long, window_fast=macd_short)
    df['RSI'] = ta.momentum.RSIIndicator(df['close'], window=rsi_length).rsi()
    df['OBV'] = ta.volume.OnBalanceVolumeIndicator(df['close'], df['volume']).on_balance_volume()
    df['ATR'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close'], window=atr_length).average_true_range()
    return df

# - Simula√ß√£o da estrat√©gia com log das opera√ß√µes
def simulate(params, df):
    """ Simula a estrat√©gia de trading e retorna o lucro final """
    balance = 1000  # Saldo inicial fict√≠cio
    position = None  # Indica se estamos comprados ou vendidos
    entry_price = None  # Pre√ßo de entrada da opera√ß√£o

    for i in range(1, len(df)):
        time = df.iloc[i]['time']
        price = df.iloc[i]['close']

        # - Regras de entrada
        if df.iloc[i]['MACD'] > df.iloc[i-1]['MACD'] and df.iloc[i]['RSI'] < 30:
            if position is None:  # Compra
                position = "LONG"
                entry_price = price
                trade_log.append({
                    "Data Entrada": time,
                    "Lado": position,
                    "Pre√ßo Entrada": entry_price,
                    "MACD": params['MACD_Short'],
                    "RSI": params['RSI_Length'],
                    "ATR": params['ATR_Length'],
                })

        elif df.iloc[i]['MACD'] < df.iloc[i-1]['MACD'] and df.iloc[i]['RSI'] > 70:
            if position is None:  # Venda
                position = "SHORT"
                entry_price = price
                trade_log.append({
                    "Data Entrada": time,
                    "Lado": position,
                    "Pre√ßo Entrada": entry_price,
                    "MACD": params['MACD_Short'],
                    "RSI": params['RSI_Length'],
                    "ATR": params['ATR_Length'],
                })

        # - Regras de sa√≠da
        if position == "LONG" and df.iloc[i]['RSI'] > 50:
            profit = (price - entry_price) / entry_price * 100
            trade_log[-1].update({"Data Fechamento": time, "Pre√ßo Fechamento": price, "Lucro (%)": profit})
            balance += balance * (profit / 100)
            position = None

        elif position == "SHORT" and df.iloc[i]['RSI'] < 50:
            profit = (entry_price - price) / entry_price * 100
            trade_log[-1].update({"Data Fechamento": time, "Pre√ßo Fechamento": price, "Lucro (%)": profit})
            balance += balance * (profit / 100)
            position = None

    return {"FinalProfit": balance}

# - Criando um problema QUBO para otimizar os indicadores
def create_qubo_problem():
    mdl = Model('QAOA_Trading')

    # - Vari√°veis de ajuste para cada indicador
    macd_short = mdl.integer_var(lb=5, ub=20, name='MACD_Short')
    macd_long = mdl.integer_var(lb=20, ub=50, name='MACD_Long')
    macd_signal = mdl.integer_var(lb=5, ub=15, name='MACD_Signal')
    rsi_length = mdl.integer_var(lb=7, ub=21, name='RSI_Length')
    atr_length = mdl.integer_var(lb=7, ub=21, name='ATR_Length')

    # - Fun√ß√£o objetivo: Maximizar o lucro final da estrat√©gia
    mdl.maximize(
        0.4 * macd_short + 0.3 * macd_long + 0.2 * macd_signal +
        0.5 * rsi_length + 0.3 * atr_length
    )

    # - Convers√£o para QUBO
    qp = QuadraticProgram()
    qp.from_docplex(mdl)
    return qp

# - Fun√ß√£o para rodar o QAOA e encontrar a melhor configura√ß√£o dos indicadores
def run_qaoa(df, iterations=5):
    qp = create_qubo_problem()

    # - Configurar QAOA
    estimator = Estimator()
    qaoa = QAOA(estimator, optimizer=COBYLA(), reps=iterations)
    optimizer = MinimumEigenOptimizer(qaoa)

    # - Executar o QAOA
    result = optimizer.solve(qp)

    # - Par√¢metros √≥timos encontrados
    best_params = {
        "MACD_Short": result.x[0],
        "MACD_Long": result.x[1],
        "MACD_Signal": result.x[2],
        "RSI_Length": result.x[3],
        "ATR_Length": result.x[4]
    }

    # - Simular a estrat√©gia com os melhores par√¢metros
    simulation_result = simulate(best_params, df)
    
    # - Exibir o relat√≥rio final da estrat√©gia
    print("\nüìå **Melhores Par√¢metros Encontrados:**", best_params)
    print("üìà **Lucro Final Simulado:**", simulation_result["FinalProfit"])
    
    # - Exibir logs das opera√ß√µes
    trade_df = pd.DataFrame(trade_log)
    print("\nüìä **Relat√≥rio das Ordens:**")
    print(trade_df)
    
    # - Mostrar gr√°fico das ordens
    trade_df.plot(x="Data Entrada", y="Lucro (%)", kind="bar", title="Lucro por Trade")
    plt.show()
```


Log:

```
‚úÖ 1000 candles carregados com sucesso!
üöÄ Iniciando QAOA...
üîÑ Executando otimiza√ß√£o...

**Melhores Par√¢metros Encontrados:** {'MACD_Short': np.float64(1.0), 'MACD_Long': np.float64(1.0), 'MACD_Signal': np.float64(1.0), 'RSI_Length': np.float64(1.0), 'ATR_Length': np.float64(1.0)}
üìà **Lucro Final Simulado:** 1003.8771479209456
```


De bonus vou te dar a implementa√ß√£o com o take Profit e o Stop Loss dinamicos:

```py
import numpy as np
import requests
import pandas as pd
import ta
import matplotlib.pyplot as plt
from datetime import datetime
from qiskit_optimization.translators import from_docplex_mp
from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit_algorithms import QAOA
from qiskit.primitives import Sampler
from qiskit_algorithms.optimizers import COBYLA
from qiskit_optimization.converters import QuadraticProgramToQubo
from docplex.mp.model import Model
import random

# üîπ Lista para armazenar logs das ordens abertas/fechadas
trade_log = []

# üîπ Fun√ß√£o para buscar dados do BTC/USDT em 5m da Binance
def get_binance_data(symbol="BTCUSDT", interval="5m", limit=1000):
    url = f"https://api.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={limit}"
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()  # Levanta erro se a resposta n√£o for 200
        df = pd.DataFrame(response.json(), columns=['time', 'open', 'high', 'low', 'close', 'volume',
                                                     'close_time', 'qav', 'trades', 'taker_base', 'taker_quote', 'ignore'])
        df = df[['time', 'open', 'high', 'low', 'close', 'volume']].astype(float)
        df['time'] = pd.to_datetime(df['time'], unit='ms')
        print(f"‚úÖ {len(df)} candles carregados com sucesso!")
        return df
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erro ao buscar dados da Binance: {e}")
        return None

# üîπ Calcula indicadores t√©cnicos
def calculate_indicators(df, macd_short=12, macd_long=26, macd_signal=9, rsi_length=14, atr_length=14):
    df['MACD'] = ta.trend.macd(df['close'], window_slow=macd_long, window_fast=macd_short)
    df['RSI'] = ta.momentum.RSIIndicator(df['close'], window=rsi_length).rsi()
    df['OBV'] = ta.volume.OnBalanceVolumeIndicator(df['close'], df['volume']).on_balance_volume()
    df['ATR'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close'], window=atr_length).average_true_range()
    return df

# üîπ Simula√ß√£o da estrat√©gia com TP e SL din√¢micos
def simulate(params, df):
    """ Simula a estrat√©gia de trading e retorna o lucro final com TP e SL din√¢micos """
    balance = 1000  # Saldo inicial fict√≠cio
    position = None  # Indica se estamos comprados ou vendidos
    entry_price = None  # Pre√ßo de entrada da opera√ß√£o
    take_profit = None
    stop_loss = None

    for i in range(1, len(df)):
        time = df.iloc[i]['time']
        price = df.iloc[i]['close']
        atr = df.iloc[i]['ATR']

        # üîπ Regras de entrada
        if position is None:
            if df.iloc[i]['MACD'] > df.iloc[i-1]['MACD'] and df.iloc[i]['RSI'] < 30:
                position = "LONG"
                entry_price = price
                take_profit = price + (atr * 2)  # TP din√¢mico baseado no ATR
                stop_loss = price - (atr * 1.5)  # SL din√¢mico baseado no ATR
                trade_log.append({
                    "Data Entrada": time,
                    "Lado": position,
                    "Pre√ßo Entrada": entry_price,
                    "Take Profit": take_profit,
                    "Stop Loss": stop_loss,
                    "MACD": params['MACD_Short'],
                    "RSI": params['RSI_Length'],
                    "ATR": atr,
                })

            elif df.iloc[i]['MACD'] < df.iloc[i-1]['MACD'] and df.iloc[i]['RSI'] > 70:
                position = "SHORT"
                entry_price = price
                take_profit = price - (atr * 2)
                stop_loss = price + (atr * 1.5)
                trade_log.append({
                    "Data Entrada": time,
                    "Lado": position,
                    "Pre√ßo Entrada": entry_price,
                    "Take Profit": take_profit,
                    "Stop Loss": stop_loss,
                    "MACD": params['MACD_Short'],
                    "RSI": params['RSI_Length'],
                    "ATR": atr,
                })

        # üîπ Regras de sa√≠da (TP ou SL)
        if position == "LONG":
            if price >= take_profit or price <= stop_loss:
                profit = (price - entry_price) / entry_price * 100
                trade_log[-1].update({"Data Fechamento": time, "Pre√ßo Fechamento": price, "Lucro (%)": profit})
                balance += balance * (profit / 100)
                position = None

        elif position == "SHORT":
            if price <= take_profit or price >= stop_loss:
                profit = (entry_price - price) / entry_price * 100
                trade_log[-1].update({"Data Fechamento": time, "Pre√ßo Fechamento": price, "Lucro (%)": profit})
                balance += balance * (profit / 100)
                position = None

    return {"FinalProfit": balance}

def create_qubo_problem():
    mdl = Model('QAOA_Trading')

    macd_short = mdl.binary_var(name='MACD_Short')
    macd_long = mdl.binary_var(name='MACD_Long')
    macd_signal = mdl.binary_var(name='MACD_Signal')
    rsi_length = mdl.binary_var(name='RSI_Length')
    atr_length = mdl.binary_var(name='ATR_Length')

    mdl.maximize(
        10 * macd_short + 15 * macd_long + 7 * macd_signal +
        12 * rsi_length + 9 * atr_length
    )

    problem = from_docplex_mp(mdl)

    return problem

def run_qaoa(df, iterations=5):
    qp = create_qubo_problem()

    qubo_converter = QuadraticProgramToQubo()
    qubo_problem = qubo_converter.convert(qp)

    print("üöÄ Iniciando QAOA...")
    sampler = Sampler()
    qaoa = QAOA(sampler, optimizer=COBYLA(), reps=iterations)
    optimizer = MinimumEigenOptimizer(qaoa)

    print("üîÑ Executando otimiza√ß√£o...")
    result = optimizer.solve(qubo_problem)

    
    best_params = {qp.variables[i].name: result.x[i] for i in range(len(result.x))}

    print("\nüìå **Melhores Par√¢metros Encontrados:**", best_params)

    simulation_result = simulate(best_params, df)

    print("üìà **Lucro Final Simulado:**", simulation_result["FinalProfit"])



df = get_binance_data()
if df is not None:
    df = calculate_indicators(df)
    run_qaoa(df, iterations=10)

```

![at√© mais](https://i.imgur.com/YNns6u1.png)


Bom agora √© s√≥ voc√™ se aventurar em testar v√°rias combina√ß√µes de indicadores.





![Quantum Hive Fund](https://i.imgur.com/0gW8QpP.png)
